Part One:
    - Hashing is a mathematical function that turns data into a scrambled string of characters
    - Encryption is like a suitcase with a key you can unlock it(decrypt)
    - When a user logs in you don't decrypt, you take the password, hash it, and see if the hash matches
    - Salting, if 2 users have same passwords, their hashes will look exactly the same 
    a hacker  could use a "Rainbow Table" (a giant list of pre-calculated hashes), to reverse them 
Fix: Salting: we can add a random string before it goes into the hash

Part Two:
    - We will use werkzeug.security, It comes installed with Flask,
    and handles comples math (algorithms like, scrypt or pdbkdf2) and automatic salting for you
    - functions used, generate_password_hash(password): Turns "monkey123" into scrypt:32768:8:1$kPv...,
    check_password_hash(hash, password): Takes the stored hash and the guess, and returns True or False

Part 3:
    - The Project (Admin Signup & Verification)
Day-Two:
    The secret_key is the most important component of your security system.
    if a hacker gets this key they can impersonate anyone, (even CEO)
    -You can get a security key by typing any string (for learning and development)
    -For production you must generate a long, random unguessable string.(nebver type it).
    run these two lines in your terminal `import secrets print(secrets.token_hex(32))

Part One:
send data(clent)->server generatestoken and hashes password
client saves login in browser->sends get and verifies
    A JSON Web Token is just a text string seperated by dots(.):
    Header.Payload.Signature:
    * Header(The "What"): Describes the token("I am JWT using HS256 alg)
    * Payload(The "Who"): Contains the data. We put the user ID e.g{"sub":1,"role":"admin"}
    Anyone can read this part(It's just Base 64 Encoded, not encrypted don't put password here)
    * Signature (The Proof): The server takes the Header+Payload+Your Secret Key and mixes them mathematically
    Why the Secret key matters:
    When a user sends a token back to you, your Flask app recalculates the Signature
    using the secret key you have on the server.
    * if the user tries to change the Payload(change role to admin) signature won't match
    * Flask will instantly reject with "Signature Verification faiiled"
    
